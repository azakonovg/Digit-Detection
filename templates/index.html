<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digit Detection App</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .main-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
        }
        .section-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .drawing-section, .result-section {
            min-width: 300px;
        }
        h1 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        }
        h2 {
            margin: 0 0 15px 0;
            color: #444;
            font-size: 18px;
        }
        .canvas-container {
            text-align: center;
        }
        #drawingCanvas {
            border: 2px solid #000;
            border-radius: 5px;
            cursor: crosshair;
            background-color: white;
            max-width: 100%;
            height: auto;
        }
        .btn {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            margin: 5px;
            border-radius: 5px;
            transition: background-color 0.3s;
            font-size: 14px;
        }
        .btn:hover {
            background-color: #45a049;
        }
        .btn.clear {
            background-color: #f44336;
        }
        .btn.clear:hover {
            background-color: #da190b;
        }
        .controls {
            margin: 10px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .result-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .image-card {
            background: #fafafa;
            padding: 8px;
            border-radius: 5px;
            text-align: center;
        }
        .image-card img {
            width: 80px;
            height: 80px;
            border-radius: 4px;
            object-fit: contain;
        }
        .prediction {
            font-size: 16px;
            font-weight: bold;
            color: #2196F3;
            margin: 5px 0;
        }
        .training-section {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 15px;
        }
        .training-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        .progress-container {
            flex: 2;
        }
        .progress-bar {
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }
        #epochs {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #trainingStatus {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .mnist-samples-section {
            margin: 20px 0;
            text-align: center;
        }
        .mnist-controls {
            margin: 10px 0;
        }
        .mnist-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            padding: 15px;
            background: #fafafa;
            border-radius: 5px;
            margin-top: 10px;
        }
        .mnist-sample {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            padding: 5px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .mnist-sample img {
            width: 60px;
            height: 60px;
            object-fit: contain;
            margin-bottom: 5px;
        }
        .mnist-sample .label {
            font-size: 12px;
            color: #666;
        }
        .btn.reset {
            background-color: #ff9800;
        }
        .btn.reset:hover {
            background-color: #f57c00;
        }
        .dataset-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .dataset-info ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .dataset-info li {
            margin: 5px 0;
            color: #555;
        }
        .dataset-info p {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        .section-header {
            margin-bottom: 15px;
            text-align: center;
            width: 100%;
        }
        .section-header h2 {
            margin: 0;
            width: 100%;
            text-align: center;
        }
        .dataset-info {
            font-size: 14px;
            color: #666;
            background: #f8f9fa;
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
        }
        .network-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        .network-visualization {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            padding: 40px 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
            min-height: 500px;
            overflow-x: auto;
        }
        .layer-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            z-index: 2;
            min-width: 120px;
            margin: 0 10px;
        }
        .layer-title {
            font-size: 14px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            text-align: center;
        }
        .neurons {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(52, 152, 219, 0.1);
            padding: 10px;
            border-radius: 10px;
            min-height: 200px;
            position: relative;
        }
        .neuron {
            width: 20px;
            height: 20px;
            background: #3498db;
            border-radius: 50%;
            margin: 2px;
            position: relative;
            z-index: 2;
            border: 2px solid #2980b9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        .neuron:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .output-neuron {
            cursor: pointer;
        }
        .neuron-label {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: white;
            font-weight: bold;
        }
        .neuron-group {
            width: 24px;
            height: 60px;
            background: #3498db;
            border-radius: 12px;
            position: relative;
            margin: 4px 0;
            border: 2px solid #2980b9;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
        }
        .layer-info {
            text-align: center;
            margin-top: 15px;
            font-size: 12px;
            color: #666;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 5px;
            width: 100%;
        }
        .activation-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 13px;
            color: #e74c3c;
            background: #fff;
            padding: 2px 8px;
            border-radius: 10px;
            border: 1px solid #e74c3c;
        }
        .total-params {
            font-size: 16px;
            color: #2c3e50;
            margin-top: 20px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 5px;
            display: inline-block;
        }
        .network-controls {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            text-align: center;
        }
        .hidden-size-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .hidden-size-control input[type="range"] {
            width: 200px;
        }
        .hidden-size-control input[type="number"] {
            width: 70px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .hidden-size-label {
            font-size: 14px;
            color: #2c3e50;
        }
        .layer-controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        .layer-input {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .layer-input label {
            margin-right: 10px;
            min-width: 100px;
        }
        .layer-input input {
            width: 100px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .layer-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        .update-btn {
            margin-left: auto;
            background-color: #2ecc71;
        }
        .update-btn:hover {
            background-color: #27ae60;
        }
        .connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        
        /* Weights table styles */
        .weights-table-section {
            margin-top: 30px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .weights-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .weights-table th, .weights-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .weights-table th {
            background-color: #f2f2f2;
            font-weight: bold;
            position: sticky;
            top: 0;
        }
        
        .weights-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .weights-table tr:hover {
            background-color: #f1f1f1;
        }
        
        .positive-weight {
            color: #2ecc71;
        }
        
        .negative-weight {
            color: #e74c3c;
        }
        
        .weights-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .weights-container {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Digit Detection App</h1>
    
    <!-- Training Section at the top -->
    <div class="section-card training-section">
        <div class="training-controls">
            <label for="epochs">Epochs:</label>
            <input type="number" id="epochs" value="5" min="1" max="100">
            <button id="trainButton" class="btn" onclick="startTraining()">Train Model</button>
            <button id="resetButton" class="btn reset" onclick="resetModel()">Reset Model</button>
            <button id="accuracyButton" class="btn" onclick="getModelAccuracy()">Get Accuracy</button>
        </div>
        <div class="progress-container">
            <div class="progress-bar">
                <div id="trainingProgress" class="progress-bar-fill"></div>
            </div>
            <div id="trainingStatus">Not started</div>
            <div id="modelAccuracy"></div>
        </div>
    </div>

    <!-- MNIST Samples Section -->
    <div class="section-card mnist-samples-section">
        <div class="section-header">
            <h2>MNIST Training Samples (<span id="trainSize">Loading...</span> images)</h2>
        </div>
        <div class="mnist-controls">
            <button class="btn" onclick="loadMNISTSamples()">Load New Samples</button>
        </div>
        <div class="mnist-grid" id="mnistSamples"></div>
    </div>

    <!-- Main content in two columns -->
    <div class="main-container">
        <!-- Drawing Section -->
        <div class="section-card drawing-section">
            <h2>Draw a Digit</h2>
            <div class="canvas-container">
                <canvas id="drawingCanvas" width="280" height="280"></canvas>
                <div class="controls">
                    <button class="btn clear" onclick="clearCanvas()">Clear</button>
                    <button class="btn" onclick="submitDrawing()">Submit</button>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div class="section-card result-section">
            <h2>Results</h2>
            <div class="result-container" id="resultContainer">
            </div>
        </div>
    </div>

    <div class="container">
        <h2 class="section-header" style="margin-top: 40px;">Simple Neural Network for Digit Recognition</h2>
        <div class="network-info" id="networkInfo">
            <!-- Network information will be populated here -->
        </div>
        
        <div class="network-controls">
            <div class="layer-controls">
                <h3>Hidden Layers Configuration</h3>
                <div id="layerInputs">
                    <!-- Layer inputs will be added here dynamically -->
                </div>
                <div class="layer-buttons">
                    <button class="btn" onclick="addLayer()">Add Layer</button>
                    <button class="btn" onclick="removeLayer()">Remove Layer</button>
                    <button class="btn update-btn" onclick="updateArchitecture()">Update Network</button>
                </div>
            </div>
        </div>
        
        <!-- Weights Table Section -->
        <div class="weights-table-section">
            <h2>Model Weights</h2>
            <p>This table shows the strongest connections between neurons in the network. Positive weights are shown in green, negative weights in red.</p>
            
            <div class="weights-controls">
                <label for="weightLimit">Max weights per layer:</label>
                <input type="number" id="weightLimit" value="50" min="10" max="1000" step="10">
                <button class="btn" onclick="loadModelWeights()">Refresh Weights</button>
            </div>
            
            <div class="weights-container">
                <table class="weights-table" id="weightsTable">
                    <thead>
                        <tr>
                            <th>From Layer</th>
                            <th>From Neuron</th>
                            <th>To Layer</th>
                            <th>To Neuron</th>
                            <th>Weight Value</th>
                        </tr>
                    </thead>
                    <tbody id="weightsTableBody">
                        <tr>
                            <td colspan="5">Loading weights data...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
    function loadNetworkInfo() {
        // Show loading indicator
        const container = document.getElementById('networkInfo');
        container.innerHTML = '<div style="text-align: center; padding: 20px;">Loading network visualization...</div>';
        
        fetch('/get_network_info')
            .then(response => response.json())
            .then(data => {
                const hiddenLayers = data.layers.filter(layer => layer.name.includes('Hidden Layer'));
                
                let html = `
                    <div class="network-visualization">
                        <!-- SVG container for connections -->
                        <svg class="connections" width="100%" height="100%">
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#95a5a6"/>
                                </marker>
                            </defs>
                        </svg>
                        <!-- Input Layer -->
                        <div class="layer-column">
                            <div class="layer-title">Input Layer<br>28×28 pixels</div>
                            <div class="neurons">
                                <div class="neuron"></div>
                                <div class="neuron"></div>
                                <div class="neuron-group">780</div>
                                <div class="neuron"></div>
                                <div class="neuron"></div>
                            </div>
                            <div class="layer-info">
                                784 input neurons<br>
                                (one per pixel)<br>
                                Flattened 28×28 image
                            </div>
                        </div>`;
                        
                        // Add hidden layers
                        hiddenLayers.forEach((layer, index) => {
                            const neurons = parseInt(layer.output_shape);
                            const displayNeurons = neurons <= 5 ? neurons : 5;
                            const remainingNeurons = neurons - displayNeurons;
                            
                            html += `
                                <div class="layer-column">
                                    <div class="layer-title">Hidden Layer ${index + 1}</div>
                                    <div class="neurons" style="min-height: ${Math.min(neurons * 5, 300)}px">`;
                                    
                                    // Add visible neurons
                                    for (let i = 0; i < Math.min(2, displayNeurons); i++) {
                                        html += `<div class="neuron"></div>`;
                                    }
                                    
                                    // Add neuron group if there are remaining neurons
                                    if (remainingNeurons > 0) {
                                        html += `<div class="neuron-group">+${remainingNeurons}</div>`;
                                    }
                                    
                                    // Add remaining visible neurons
                                    for (let i = Math.max(0, displayNeurons - 2); i < displayNeurons; i++) {
                                        html += `<div class="neuron"></div>`;
                                    }
                                    
                                    html += `
                                    </div>
                                    <div class="layer-info">
                                        ${neurons} neurons<br>
                                        ReLU activation<br>
                                        ${layer.parameters.toLocaleString()} parameters<br>
                                        <span style="font-size: 10px; color: #888;">
                                            (${layer.weights.toLocaleString()} weights + ${layer.biases.toLocaleString()} biases)
                                        </span>
                                    </div>
                                </div>`;
                        });
                        
                        // Add output layer
                        html += `
                                <div class="layer-column">
                                    <div class="layer-title">Output Layer</div>
                                    <div class="neurons">
                                        <div class="neuron output-neuron" data-digit="0"><span class="neuron-label">0</span></div>
                                        <div class="neuron output-neuron" data-digit="1"><span class="neuron-label">1</span></div>
                                        <div class="neuron output-neuron" data-digit="2"><span class="neuron-label">2</span></div>
                                        <div class="neuron output-neuron" data-digit="3"><span class="neuron-label">3</span></div>
                                        <div class="neuron output-neuron" data-digit="4"><span class="neuron-label">4</span></div>
                                        <div class="neuron output-neuron" data-digit="5"><span class="neuron-label">5</span></div>
                                        <div class="neuron output-neuron" data-digit="6"><span class="neuron-label">6</span></div>
                                        <div class="neuron output-neuron" data-digit="7"><span class="neuron-label">7</span></div>
                                        <div class="neuron output-neuron" data-digit="8"><span class="neuron-label">8</span></div>
                                        <div class="neuron output-neuron" data-digit="9"><span class="neuron-label">9</span></div>
                                    </div>
                                    <div class="layer-info">
                                        10 output neurons<br>
                                        Softmax activation<br>
                                        ${data.layers[data.layers.length-1].parameters.toLocaleString()} parameters<br>
                                        <span style="font-size: 10px; color: #888;">
                                            (${data.layers[data.layers.length-1].weights.toLocaleString()} weights + 
                                            ${data.layers[data.layers.length-1].biases.toLocaleString()} biases)
                                        </span>
                                    </div>
                                </div>
                            </div>
                            <div class="total-params">Total Learnable Parameters: ${data.total_parameters.toLocaleString()}</div>
                            <div class="weight-explanation" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                                <h4 style="color: #2c3e50; margin-bottom: 10px;">Neural Network Weights</h4>
                                <p style="color: #666; line-height: 1.5;">
                                    Lines show connections between neurons. Thicker lines mean stronger connections.
                                    During training, these connections automatically adjust to recognize digits better.
                                </p>
                            </div>
                            <p style="margin-top: 15px; color: #666;">
                                Each neuron processes its inputs and passes results to the next layer. 
                                ReLU activation helps learn patterns, and the final layer predicts the digit (0-9).
                            </p>`;
                        
                        container.innerHTML = html;
                        
                        // Add connection lines after the elements are added to the DOM
                        setTimeout(drawConnections, 100);
            })
            .catch(error => {
                console.error('Error loading network info:', error);
            });
    }
    
    function drawConnections() {
        const svg = document.querySelector('.connections');
        if (!svg) return;
        
        const layers = document.querySelectorAll('.layer-column');
        
        // Clear existing lines
        while (svg.lastChild) {
            if (svg.lastChild.tagName === 'defs') break;
            svg.removeChild(svg.lastChild);
        }
        
        // Generate some example weights for visualization
        const exampleWeights = [
            { from: 0, to: 0, weight: 0.8 },
            { from: 0, to: 1, weight: 0.3 },
            { from: 1, to: 0, weight: 0.6 },
            { from: 1, to: 1, weight: 0.1 },
        ];
        
        // Draw connections between layers
        for (let i = 0; i < layers.length - 1; i++) {
            const currentLayer = layers[i];
            const nextLayer = layers[i + 1];
            const currentNeurons = currentLayer.querySelectorAll('.neuron, .neuron-group');
            const nextNeurons = nextLayer.querySelectorAll('.neuron, .neuron-group');
            
            currentNeurons.forEach((fromNeuron, fromIndex) => {
                const fromRect = fromNeuron.getBoundingClientRect();
                const fromX = fromRect.right - svg.getBoundingClientRect().left;
                const fromY = fromRect.top - svg.getBoundingClientRect().top + fromRect.height / 2;
                
                nextNeurons.forEach((toNeuron, toIndex) => {
                    // Skip some connections for visual clarity
                    if ((fromIndex + toIndex) % 2 === 0) {
                        const toRect = toNeuron.getBoundingClientRect();
                        const toX = toRect.left - svg.getBoundingClientRect().left;
                        const toY = toRect.top - svg.getBoundingClientRect().top + toRect.height / 2;
                        
                        // Find if this is one of our example connections
                        const exampleWeight = exampleWeights.find(w => 
                            i === 0 && w.from === fromIndex && w.to === toIndex
                        );
                        
                        // Use example weight or random weight
                        const weight = exampleWeight ? exampleWeight.weight : Math.random() * 0.3 + 0.1;
                        
                        // Calculate line properties based on weight
                        const strokeWidth = Math.max(1, weight * 10);  // Reduced from 20 to 10 for thinner lines
                        const opacity = Math.max(0.2, weight);  // Slightly reduced minimum opacity
                        
                        // Create background line (shadow effect)
                        const shadowLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const controlPoint1X = fromX + (toX - fromX) * 0.4;
                        const controlPoint2X = fromX + (toX - fromX) * 0.6;
                        
                        shadowLine.setAttribute('d', `M ${fromX} ${fromY} C ${controlPoint1X} ${fromY}, ${controlPoint2X} ${toY}, ${toX} ${toY}`);
                        shadowLine.setAttribute('stroke', '#e0e0e0');
                        shadowLine.setAttribute('stroke-width', strokeWidth + 2);
                        shadowLine.setAttribute('fill', 'none');
                        shadowLine.setAttribute('opacity', 0.5);
                        svg.appendChild(shadowLine);
                        
                        // Create main connection line
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        line.setAttribute('d', shadowLine.getAttribute('d'));
                        line.setAttribute('stroke', '#2c3e50');
                        line.setAttribute('stroke-width', strokeWidth);
                        line.setAttribute('fill', 'none');
                        line.setAttribute('opacity', opacity);
                        svg.appendChild(line);
                        
                        // Add weight label for example connections
                        if (exampleWeight) {
                            const pathLength = line.getTotalLength();
                            const midPoint = line.getPointAtLength(pathLength / 2);
                            
                            // Create label background
                            const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            labelBg.setAttribute('x', midPoint.x - 20);
                            labelBg.setAttribute('y', midPoint.y - 12);
                            labelBg.setAttribute('width', 40);
                            labelBg.setAttribute('height', 20);
                            labelBg.setAttribute('fill', 'white');
                            labelBg.setAttribute('rx', 5);
                            svg.appendChild(labelBg);
                            
                            // Create weight label
                            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            label.setAttribute('x', midPoint.x);
                            label.setAttribute('y', midPoint.y + 5);
                            label.setAttribute('text-anchor', 'middle');
                            label.setAttribute('fill', '#2c3e50');
                            label.setAttribute('font-size', '12px');
                            label.setAttribute('font-weight', 'bold');
                            label.textContent = weight.toFixed(1);
                            svg.appendChild(label);
                        }
                    }
                });
            });
        }
    }

    // Add window resize handler to redraw connections
    window.addEventListener('resize', drawConnections);

    // Call this function when the page loads
    document.addEventListener('DOMContentLoaded', function() {
        loadNetworkInfo();
        loadMNISTSamples();
    });
    </script>

    <script>
        const STATIC_URL = "{{ url_for('static', filename='') }}";
        
        // Canvas drawing functionality
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Set up canvas
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 15;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Initialize canvas with white background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Drawing event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch support
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', stopDrawing);

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX - rect.left,
                clientY: touch.clientY - rect.top
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX - rect.left,
                clientY: touch.clientY - rect.top
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function draw(e) {
            if (!isDrawing) return;
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function clearCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function submitDrawing() {
            const imageData = canvas.toDataURL('image/png');
            
            const form = new FormData();
            form.append('image_data', imageData);
            
            fetch('/', {
                method: 'POST',
                body: form
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const imageCard = document.createElement('div');
                    imageCard.className = 'image-card';
                    imageCard.innerHTML = `
                        <img src="${STATIC_URL}${data.image_path}" alt="Drawn Digit">
                        <div class="prediction">
                            Predicted: ${data.prediction}
                        </div>
                    `;
                    
                    const resultContainer = document.getElementById('resultContainer');
                    resultContainer.insertBefore(imageCard, resultContainer.firstChild);
                    
                    // Update neuron colors if probabilities are provided
                    if (data.probabilities) {
                        updateNeuronColors(data.probabilities);
                        
                        // Optionally refresh weights table 
                        // to show weights for the predicted digit
                        loadModelWeights();
                    } else {
                        // If no probabilities provided, highlight only the predicted digit
                        const singlePrediction = {};
                        singlePrediction[data.prediction] = 1.0;
                        updateNeuronColors(singlePrediction);
                    }
                    
                    clearCanvas();
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error submitting drawing. Details: ' + error.message);
            });
        }

        // Function to update neuron colors based on prediction probabilities
        function updateNeuronColors(probabilities) {
            // Reset all neurons to default color
            const outputNeurons = document.querySelectorAll('.output-neuron');
            outputNeurons.forEach(neuron => {
                neuron.style.background = '#3498db';  // Default blue color
                neuron.style.borderColor = '#2980b9';
                neuron.style.transform = 'scale(1)';
            });
            
            // Find the highest probability
            let highestProb = 0;
            let predictedDigit = null;
            
            for (const digit in probabilities) {
                const probability = probabilities[digit];
                if (probability > highestProb) {
                    highestProb = probability;
                    predictedDigit = digit;
                }
            }
            
            // Update colors based on probabilities
            for (const digit in probabilities) {
                const probability = probabilities[digit];
                const neuron = document.querySelector(`.output-neuron[data-digit="${digit}"]`);
                
                if (neuron) {
                    // Calculate color - red intensity based on probability
                    const green = Math.floor(255 * (1 - probability));
                    const blue = Math.floor(255 * (1 - probability));
                    neuron.style.background = `rgb(255, ${green}, ${blue})`;
                    neuron.style.borderColor = '#c0392b';
                    
                    // Scale size based on probability (but not too much)
                    const scale = 1 + (probability * 0.5);
                    neuron.style.transform = `scale(${scale})`;
                    
                    // Add tooltip with exact probability
                    neuron.title = `Probability: ${(probability * 100).toFixed(2)}%`;
                }
            }
            
            // If we have a prediction, highlight relevant weights in the table
            if (predictedDigit !== null) {
                highlightWeightsForDigit(predictedDigit);
            }
        }
        
        // Function to highlight weights for a specific digit
        function highlightWeightsForDigit(digit) {
            const rows = document.querySelectorAll('#weightsTableBody tr');
            
            // Reset all rows
            rows.forEach(row => {
                row.style.backgroundColor = '';
                row.style.fontWeight = 'normal';
            });
            
            // Highlight rows connecting to the specified digit
            rows.forEach(row => {
                const toLayerCell = row.cells[2];
                const toNeuronCell = row.cells[3];
                
                if (toLayerCell && toNeuronCell && 
                    toLayerCell.textContent.trim() === 'Output' && 
                    toNeuronCell.textContent.trim() === digit) {
                    row.style.backgroundColor = '#e8f8f5';
                    row.style.fontWeight = 'bold';
                }
            });
        }

        function startTraining() {
            const epochs = document.getElementById('epochs').value || 5;
            const progressBar = document.getElementById('trainingProgress');
            const statusText = document.getElementById('trainingStatus');
            const accuracyDisplay = document.getElementById('modelAccuracy');
            const trainButton = document.getElementById('trainButton');
            
            // Disable the train button during training
            trainButton.disabled = true;
            progressBar.style.width = '0%';
            statusText.textContent = 'Starting training...';
            accuracyDisplay.textContent = '';
            
            const eventSource = new EventSource(`/train?epochs=${epochs}`);
            
            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                
                if (data.status === 'error') {
                    statusText.textContent = `Error: ${data.message}`;
                    progressBar.classList.add('bg-danger');
                    eventSource.close();
                    trainButton.disabled = false;
                    return;
                }
                
                if (data.status === 'completed') {
                    statusText.textContent = data.message;
                    progressBar.style.width = '100%';
                    progressBar.classList.remove('bg-danger');
                    progressBar.classList.add('bg-success');
                    eventSource.close();
                    trainButton.disabled = false;
                    
                    // Add a small delay before getting accuracy and refreshing visualizations
                    setTimeout(() => {
                        getModelAccuracy();
                        // Refresh weights
                        loadModelWeights();
                        // Refresh network visualization
                        loadNetworkInfo();
                    }, 1000);
                    return;
                }
                
                // Regular progress update
                if (data.batch !== undefined && data.total_batches !== undefined) {
                    const progress = (data.batch / data.total_batches) * 100;
                    progressBar.style.width = `${progress}%`;
                    statusText.textContent = `Epoch ${data.epoch}, Batch ${data.batch}/${data.total_batches}, ` +
                                          `Loss: ${data.loss.toFixed(4)}, Accuracy: ${data.accuracy.toFixed(2)}%`;
                }
            };
            
            eventSource.onerror = function(error) {
                console.error('EventSource error:', error);
                statusText.textContent = 'Training completed. Getting final accuracy...';
                progressBar.classList.add('bg-success');
                eventSource.close();
                trainButton.disabled = false;
                
                // Get accuracy after error/completion
                setTimeout(() => {
                    getModelAccuracy();
                }, 1000);
            };
        }

        function loadMNISTSamples() {
            fetch('/get_mnist_samples?num_samples=10')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const container = document.getElementById('mnistSamples');
                        container.innerHTML = '';
                        
                        data.samples.forEach(sample => {
                            const div = document.createElement('div');
                            div.className = 'mnist-sample';
                            div.innerHTML = `
                                <img src="data:image/png;base64,${sample.image}" alt="MNIST ${sample.label}">
                                <span class="label">Label: ${sample.label}</span>
                            `;
                            container.appendChild(div);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error loading MNIST samples:', error);
                });
        }

        function resetModel() {
            const resetButton = document.getElementById('resetButton');
            const trainButton = document.getElementById('trainButton');
            const statusText = document.getElementById('trainingStatus');
            const accuracyDisplay = document.getElementById('modelAccuracy');
            
            // Disable buttons during reset
            resetButton.disabled = true;
            trainButton.disabled = true;
            statusText.textContent = 'Resetting model weights...';
            
            fetch('/reset_model', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    statusText.textContent = 'Model reset successfully. Ready for training.';
                    if (data.accuracy !== undefined) {
                        accuracyDisplay.textContent = `Model Accuracy after reset: ${data.accuracy.toFixed(2)}%`;
                    }
                    // Clear any existing results since they're no longer valid
                    document.getElementById('resultContainer').innerHTML = '';
                    
                    // Reload network visualization to show reset weights
                    loadNetworkInfo();
                    
                    // Reload weights table
                    loadModelWeights();
                } else {
                    statusText.textContent = `Error: ${data.error}`;
                }
            })
            .catch(error => {
                console.error('Error:', error);
                statusText.textContent = 'Error resetting model';
            })
            .finally(() => {
                // Re-enable buttons
                resetButton.disabled = false;
                trainButton.disabled = false;
            });
        }

        function getModelAccuracy() {
            const accuracyButton = document.getElementById('accuracyButton');
            const accuracyDisplay = document.getElementById('modelAccuracy');
            
            accuracyButton.disabled = true;
            accuracyDisplay.textContent = 'Calculating accuracy...';
            
            fetch('/get_accuracy')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        accuracyDisplay.textContent = `Model Accuracy: ${data.accuracy.toFixed(2)}%`;
                        
                        // Refresh weights after getting accuracy
                        loadModelWeights();
                    } else {
                        accuracyDisplay.textContent = `Error getting accuracy: ${data.error}`;
                    }
                })
                .catch(error => {
                    accuracyDisplay.textContent = `Error: ${error.message}`;
                })
                .finally(() => {
                    accuracyButton.disabled = false;
                });
        }

        function loadDatasetInfo() {
            fetch('/get_dataset_info')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const info = data.info;
                        document.getElementById('trainSize').textContent = info.train_size.toLocaleString();
                    } else {
                        console.error('Error loading dataset info:', data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }

        // Load samples when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadMNISTSamples();
            loadDatasetInfo();
        });

        // Add these functions for hidden size control
        function initHiddenSizeControls() {
            const slider = document.getElementById('hiddenSizeSlider');
            const input = document.getElementById('hiddenSizeInput');
            
            slider.addEventListener('input', (e) => {
                input.value = e.target.value;
            });
            
            input.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                if (value < 1) input.value = 1;
                if (value > 256) input.value = 256;
                slider.value = input.value;
            });
        }
        
        function updateHiddenSize() {
            const newSize = parseInt(document.getElementById('hiddenSizeInput').value);
            const button = document.querySelector('.hidden-size-control button');
            button.disabled = true;
            
            fetch('/update_hidden_size', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ hidden_size: newSize })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Reload network visualization
                    loadNetworkInfo();
                    // Reset model accuracy display
                    const accuracyDisplay = document.getElementById('modelAccuracy');
                    if (accuracyDisplay) accuracyDisplay.textContent = '';
                } else {
                    alert('Error updating network: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error updating network');
            })
            .finally(() => {
                button.disabled = false;
            });
        }
        
        // Update the DOMContentLoaded event listener
        document.addEventListener('DOMContentLoaded', function() {
            initHiddenSizeControls();
            loadNetworkInfo();
            loadMNISTSamples();
        });

        function initLayerControls() {
            // Get current model architecture
            fetch('/get_network_info')
                .then(response => response.json())
                .then(data => {
                    const container = document.getElementById('layerInputs');
                    container.innerHTML = ''; // Clear existing inputs
                    
                    // Filter hidden layers
                    const hiddenLayers = data.layers.filter(layer => layer.name.includes('Hidden Layer'));
                    
                    // Add input for each hidden layer
                    hiddenLayers.forEach((layer, index) => {
                        const layerDiv = document.createElement('div');
                        layerDiv.className = 'layer-input';
                        layerDiv.innerHTML = `
                            <label>Hidden Layer ${index + 1}:</label>
                            <input type="number" class="layer-size" value="${layer.output_shape}" min="1" max="1000">
                            <span style="margin-left: 10px;">neurons</span>
                        `;
                        container.appendChild(layerDiv);
                    });
                })
                .catch(error => {
                    console.error('Error loading network architecture:', error);
                    // Add at least one layer as fallback
                    addLayer();
                });
        }
        
        function addLayer() {
            const container = document.getElementById('layerInputs');
            const layerCount = container.children.length;
            
            if (layerCount >= 5) {
                alert('Maximum 5 hidden layers allowed');
                return;
            }
            
            const layerDiv = document.createElement('div');
            layerDiv.className = 'layer-input';
            layerDiv.innerHTML = `
                <label>Hidden Layer ${layerCount + 1}:</label>
                <input type="number" class="layer-size" value="128" min="1" max="1000">
                <span style="margin-left: 10px;">neurons</span>
            `;
            
            container.appendChild(layerDiv);
        }
        
        function removeLayer() {
            const container = document.getElementById('layerInputs');
            if (container.children.length > 1) {
                container.removeChild(container.lastChild);
            }
        }
        
        function updateArchitecture() {
            const layers = Array.from(document.getElementsByClassName('layer-size'))
                .map(input => parseInt(input.value))
                .filter(size => !isNaN(size));  // Filter out any invalid values
            
            if (layers.length === 0) {
                alert('Please add at least one hidden layer');
                return;
            }
            
            if (!layers.every(size => size >= 1 && size <= 1000)) {
                alert('Each layer must have between 1 and 1000 neurons');
                return;
            }
            
            const button = document.querySelector('.update-btn');
            const statusText = document.getElementById('trainingStatus');
            button.disabled = true;
            statusText.textContent = 'Updating network architecture...';
            
            fetch('/update_hidden_size', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ layers: layers })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    statusText.textContent = `Network architecture updated successfully with layers: ${layers.join(', ')}`;
                    
                    // Reload network visualization
                    loadNetworkInfo();
                    
                    // Reset model accuracy display
                    const accuracyDisplay = document.getElementById('modelAccuracy');
                    if (accuracyDisplay) accuracyDisplay.textContent = 'Model architecture changed. Please train the model.';
                    
                    // Reload weights table
                    loadModelWeights();
                } else {
                    const errorMessage = data.error || 'Unknown error occurred';
                    statusText.textContent = `Error: ${errorMessage}`;
                    alert('Error updating network: ' + errorMessage);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                statusText.textContent = 'Failed to update network architecture';
                alert('Error updating network: ' + error.message);
            })
            .finally(() => {
                button.disabled = false;
            });
        }
        
        // Update the DOMContentLoaded event listener
        document.addEventListener('DOMContentLoaded', function() {
            initLayerControls();
            loadNetworkInfo();
            loadMNISTSamples();
        });
    </script>

    <script>
        function loadModelWeights() {
            const limit = document.getElementById('weightLimit').value || 50;
            const tableBody = document.getElementById('weightsTableBody');
            
            // Show loading message
            tableBody.innerHTML = '<tr><td colspan="5">Loading weights data...</td></tr>';
            
            fetch(`/get_model_weights?limit=${limit}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        let html = '';
                        
                        // Add weights to output neurons first
                        if (data.output_layer_weights && data.output_layer_weights.length > 0) {
                            data.output_layer_weights.forEach(w => {
                                const weightClass = w.weight >= 0 ? 'positive-weight' : 'negative-weight';
                                html += `
                                    <tr>
                                        <td>${w.from_layer}</td>
                                        <td>${w.from_neuron}</td>
                                        <td>${w.to_layer}</td>
                                        <td>${w.to_neuron}</td>
                                        <td class="${weightClass}">${w.weight.toFixed(4)}</td>
                                    </tr>
                                `;
                            });
                        }
                        
                        // Add weights between hidden layers
                        if (data.hidden_layer_weights && data.hidden_layer_weights.length > 0) {
                            data.hidden_layer_weights.forEach(w => {
                                const weightClass = w.weight >= 0 ? 'positive-weight' : 'negative-weight';
                                html += `
                                    <tr>
                                        <td>${w.from_layer}</td>
                                        <td>${w.from_neuron}</td>
                                        <td>${w.to_layer}</td>
                                        <td>${w.to_neuron}</td>
                                        <td class="${weightClass}">${w.weight.toFixed(4)}</td>
                                    </tr>
                                `;
                            });
                        }
                        
                        if (html === '') {
                            html = '<tr><td colspan="5">No weight data available</td></tr>';
                        } else {
                            // Add summary at the end
                            html += `
                                <tr>
                                    <td colspan="5" style="text-align: center; font-style: italic; background-color: #f8f9fa;">
                                        Showing ${data.shown_weights} weights out of ${data.total_weights.toLocaleString()} total weights
                                    </td>
                                </tr>
                            `;
                        }
                        
                        tableBody.innerHTML = html;
                    } else {
                        tableBody.innerHTML = `<tr><td colspan="5">Error loading weights: ${data.error || 'Unknown error'}</td></tr>`;
                    }
                })
                .catch(error => {
                    console.error('Error loading model weights:', error);
                    tableBody.innerHTML = `<tr><td colspan="5">Error loading weights: ${error.message}</td></tr>`;
                });
        }
        
        // Load weights when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Add to existing listeners
            loadModelWeights();
        });
    </script>
</body>
</html> 