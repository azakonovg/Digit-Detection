<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digit Detection App</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .main-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
        }
        .section-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .drawing-section, .result-section {
            min-width: 300px;
        }
        h1 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        }
        h2 {
            margin: 0 0 15px 0;
            color: #444;
            font-size: 18px;
        }
        .canvas-container {
            text-align: center;
        }
        #drawingCanvas {
            border: 2px solid #000;
            border-radius: 5px;
            cursor: crosshair;
            background-color: white;
            max-width: 100%;
            height: auto;
        }
        .btn {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            margin: 5px;
            border-radius: 5px;
            transition: background-color 0.3s;
            font-size: 14px;
        }
        .btn:hover {
            background-color: #45a049;
        }
        .btn.clear {
            background-color: #f44336;
        }
        .btn.clear:hover {
            background-color: #da190b;
        }
        .controls {
            margin: 10px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .result-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .image-card {
            background: #fafafa;
            padding: 8px;
            border-radius: 5px;
            text-align: center;
        }
        .image-card img {
            width: 80px;
            height: 80px;
            border-radius: 4px;
            object-fit: contain;
        }
        .prediction {
            font-size: 16px;
            font-weight: bold;
            color: #2196F3;
            margin: 5px 0;
        }
        .training-section {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 15px;
        }
        .training-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        .progress-container {
            flex: 2;
        }
        .progress-bar {
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }
        #epochs {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #trainingStatus {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .mnist-samples-section {
            margin: 20px 0;
            text-align: center;
        }
        .mnist-controls {
            margin: 10px 0;
        }
        .mnist-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            padding: 15px;
            background: #fafafa;
            border-radius: 5px;
            margin-top: 10px;
        }
        .mnist-sample {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            padding: 5px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .mnist-sample img {
            width: 60px;
            height: 60px;
            object-fit: contain;
            margin-bottom: 5px;
        }
        .mnist-sample .label {
            font-size: 12px;
            color: #666;
        }
        .btn.reset {
            background-color: #ff9800;
        }
        .btn.reset:hover {
            background-color: #f57c00;
        }
        .dataset-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .dataset-info ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .dataset-info li {
            margin: 5px 0;
            color: #555;
        }
        .dataset-info p {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        .section-header {
            margin-bottom: 15px;
            text-align: center;
            width: 100%;
        }
        .section-header h2 {
            margin: 0;
            width: 100%;
            text-align: center;
        }
        .dataset-info {
            font-size: 14px;
            color: #666;
            background: #f8f9fa;
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
        }
        .network-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        .network-visualization {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            padding: 40px 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
            min-height: 400px;
        }
        .layer-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            z-index: 2;
        }
        .connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        .neuron {
            width: 24px;
            height: 24px;
            background: #3498db;
            border-radius: 50%;
            margin: 4px;
            position: relative;
            z-index: 2;
            border: 2px solid #2980b9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .neuron-group {
            width: 24px;
            height: 60px;
            background: #3498db;
            border-radius: 12px;
            position: relative;
            margin: 8px 0;
            border: 2px solid #2980b9;
        }
        .neuron-label {
            position: absolute;
            right: -25px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: #2c3e50;
        }
        .layer-info {
            text-align: center;
            margin-top: 15px;
            font-size: 13px;
            color: #666;
            background: #f8f9fa;
            padding: 5px 10px;
            border-radius: 5px;
        }
        .activation-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 13px;
            color: #e74c3c;
            background: #fff;
            padding: 2px 8px;
            border-radius: 10px;
            border: 1px solid #e74c3c;
        }
        .total-params {
            font-size: 16px;
            color: #2c3e50;
            margin-top: 20px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 5px;
            display: inline-block;
        }
        .network-controls {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            text-align: center;
        }
        .hidden-size-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .hidden-size-control input[type="range"] {
            width: 200px;
        }
        .hidden-size-control input[type="number"] {
            width: 70px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .hidden-size-label {
            font-size: 14px;
            color: #2c3e50;
        }
        .layer-controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        .layer-input {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .layer-input label {
            margin-right: 10px;
            min-width: 100px;
        }
        .layer-input input {
            width: 100px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .layer-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        .update-btn {
            margin-left: auto;
            background-color: #2ecc71;
        }
        .update-btn:hover {
            background-color: #27ae60;
        }
    </style>
</head>
<body>
    <h1>Digit Detection App</h1>
    
    <!-- Training Section at the top -->
    <div class="section-card training-section">
        <div class="training-controls">
            <label for="epochs">Epochs:</label>
            <input type="number" id="epochs" value="5" min="1" max="100">
            <button id="trainButton" class="btn" onclick="startTraining()">Train Model</button>
            <button id="resetButton" class="btn reset" onclick="resetModel()">Reset Model</button>
            <button id="accuracyButton" class="btn" onclick="getModelAccuracy()">Get Accuracy</button>
        </div>
        <div class="progress-container">
            <div class="progress-bar">
                <div id="trainingProgress" class="progress-bar-fill"></div>
            </div>
            <div id="trainingStatus">Not started</div>
            <div id="modelAccuracy"></div>
        </div>
    </div>

    <!-- MNIST Samples Section -->
    <div class="section-card mnist-samples-section">
        <div class="section-header">
            <h2>MNIST Training Samples (<span id="trainSize">Loading...</span> images)</h2>
        </div>
        <div class="mnist-controls">
            <button class="btn" onclick="loadMNISTSamples()">Load New Samples</button>
        </div>
        <div class="mnist-grid" id="mnistSamples"></div>
    </div>

    <!-- Main content in two columns -->
    <div class="main-container">
        <!-- Drawing Section -->
        <div class="section-card drawing-section">
            <h2>Draw a Digit</h2>
            <div class="canvas-container">
                <canvas id="drawingCanvas" width="280" height="280"></canvas>
                <div class="controls">
                    <button class="btn clear" onclick="clearCanvas()">Clear</button>
                    <button class="btn" onclick="submitDrawing()">Submit</button>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div class="section-card result-section">
            <h2>Results</h2>
            <div class="result-container" id="resultContainer">
            </div>
        </div>
    </div>

    <div class="container">
        <h2 class="section-header">Simple Neural Network for Digit Recognition</h2>
        <div class="network-info" id="networkInfo">
            <!-- Network information will be populated here -->
        </div>
        
        <div class="network-controls">
            <div class="layer-controls">
                <h3>Hidden Layers Configuration</h3>
                <div id="layerInputs">
                    <!-- Layer inputs will be added here dynamically -->
                </div>
                <div class="layer-buttons">
                    <button class="btn" onclick="addLayer()">Add Layer</button>
                    <button class="btn" onclick="removeLayer()">Remove Layer</button>
                    <button class="btn update-btn" onclick="updateArchitecture()">Update Network</button>
                </div>
            </div>
        </div>
        
        <script>
        function loadNetworkInfo() {
            fetch('/get_network_info')
                .then(response => response.json())
                .then(data => {
                    const container = document.getElementById('networkInfo');
                    const hiddenLayers = data.layers.filter(layer => layer.name.includes('Hidden Layer'));
                    
                    let html = `
                        <div class="network-visualization">
                            <!-- Input Layer -->
                            <div class="layer-column">
                                <div class="layer-title">Input Image<br>28Ã—28 pixels</div>
                                <div class="neurons">
                                    <div class="neuron"></div>
                                    <div class="neuron"></div>
                                    <div class="neuron-group"></div>
                                    <div class="neuron"></div>
                                    <div class="neuron"></div>
                                </div>
                                <div class="layer-info">784 input neurons<br>(one per pixel)</div>
                            </div>`;
                    
                    // Add hidden layers
                    hiddenLayers.forEach((layer, index) => {
                        html += `
                            <div class="layer-column">
                                <div class="layer-title">Hidden Layer ${index + 1}</div>
                                <div class="neurons">
                                    <div class="neuron"></div>
                                    <div class="neuron"></div>
                                    <div class="neuron-group"></div>
                                    <div class="neuron"></div>
                                    <div class="neuron"></div>
                                </div>
                                <div class="layer-info">${layer.output_shape} neurons with ReLU<br>Learning patterns</div>
                            </div>`;
                    });
                    
                    // Add output layer
                    html += `
                            <div class="layer-column">
                                <div class="layer-title">Output Layer</div>
                                <div class="neurons">
                                    <div class="neuron"><span class="neuron-label">0</span></div>
                                    <div class="neuron"><span class="neuron-label">1</span></div>
                                    <div class="neuron"><span class="neuron-label">2</span></div>
                                    <div class="neuron"><span class="neuron-label">3</span></div>
                                    <div class="neuron"><span class="neuron-label">4</span></div>
                                    <div class="neuron"><span class="neuron-label">5</span></div>
                                    <div class="neuron"><span class="neuron-label">6</span></div>
                                    <div class="neuron"><span class="neuron-label">7</span></div>
                                    <div class="neuron"><span class="neuron-label">8</span></div>
                                    <div class="neuron"><span class="neuron-label">9</span></div>
                                </div>
                                <div class="layer-info">10 output neurons<br>One per digit (0-9)</div>
                            </div>

                            <!-- Connection lines will be drawn using SVG -->
                            <svg class="connections" width="100%" height="100%" style="position: absolute; top: 0; left: 0;">
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                    refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#95a5a6"/>
                                    </marker>
                                </defs>
                                <!-- Connection lines will be added by JavaScript -->
                            </svg>
                        </div>
                        <div class="total-params">Total Learnable Parameters: ${data.total_parameters.toLocaleString()}</div>
                        <p style="margin-top: 15px; color: #666;">
                            This neural network learns to recognize handwritten digits by processing the image through multiple layers.
                            Each neuron is connected to all neurons in the next layer, and the connections (weights) are adjusted during training.
                            The ReLU activation helps the network learn complex patterns, while the final layer uses Softmax to predict the digit.
                        </p>
                    `;
                    container.innerHTML = html;
                    
                    // Add connection lines after the elements are added to the DOM
                    setTimeout(drawConnections, 100);
                })
                .catch(error => {
                    console.error('Error loading network info:', error);
                });
        }
        
        function drawConnections() {
            const svg = document.querySelector('.connections');
            const layers = document.querySelectorAll('.layer-column');
            
            // Clear existing lines
            while (svg.lastChild) {
                if (svg.lastChild.tagName === 'defs') break;
                svg.removeChild(svg.lastChild);
            }
            
            // Draw some sample connections between layers
            for (let i = 0; i < layers.length - 1; i++) {
                const currentLayer = layers[i];
                const nextLayer = layers[i + 1];
                const currentNeurons = currentLayer.querySelectorAll('.neuron');
                const nextNeurons = nextLayer.querySelectorAll('.neuron');
                
                // Draw a subset of connections for visual clarity
                currentNeurons.forEach((fromNeuron, fromIndex) => {
                    if (fromIndex % 2 === 0) {  // Draw connections from every other neuron
                        nextNeurons.forEach((toNeuron, toIndex) => {
                            if (toIndex % 2 === 0) {  // Connect to every other neuron in next layer
                                const fromRect = fromNeuron.getBoundingClientRect();
                                const toRect = toNeuron.getBoundingClientRect();
                                const svgRect = svg.getBoundingClientRect();
                                
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', fromRect.left - svgRect.left + fromRect.width/2);
                                line.setAttribute('y1', fromRect.top - svgRect.top + fromRect.height/2);
                                line.setAttribute('x2', toRect.left - svgRect.left + toRect.width/2);
                                line.setAttribute('y2', toRect.top - svgRect.top + toRect.height/2);
                                line.setAttribute('stroke', '#95a5a6');
                                line.setAttribute('stroke-width', '1');
                                line.setAttribute('opacity', '0.2');
                                svg.appendChild(line);
                            }
                        });
                    }
                });
            }
        }

        // Add window resize handler to redraw connections
        window.addEventListener('resize', drawConnections);

        // Call this function when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadNetworkInfo();
            loadMNISTSamples();
        });
    </script>

    <script>
        const STATIC_URL = "{{ url_for('static', filename='') }}";
        
        // Canvas drawing functionality
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Set up canvas
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 15;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Initialize canvas with white background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Drawing event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch support
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', stopDrawing);

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX - rect.left,
                clientY: touch.clientY - rect.top
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX - rect.left,
                clientY: touch.clientY - rect.top
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function draw(e) {
            if (!isDrawing) return;
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function clearCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function submitDrawing() {
            const imageData = canvas.toDataURL('image/png');
            
            const form = new FormData();
            form.append('image_data', imageData);
            
            fetch('/', {
                method: 'POST',
                body: form
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const imageCard = document.createElement('div');
                    imageCard.className = 'image-card';
                    imageCard.innerHTML = `
                        <img src="${STATIC_URL}${data.image_path}" alt="Drawn Digit">
                        <div class="prediction">
                            Predicted: ${data.prediction}
                        </div>
                    `;
                    
                    const resultContainer = document.getElementById('resultContainer');
                    resultContainer.insertBefore(imageCard, resultContainer.firstChild);
                    
                    clearCanvas();
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error submitting drawing. Details: ' + error.message);
            });
        }

        function startTraining() {
            const epochs = document.getElementById('epochs').value || 5;
            const progressBar = document.getElementById('trainingProgress');
            const statusText = document.getElementById('trainingStatus');
            const accuracyDisplay = document.getElementById('modelAccuracy');
            const trainButton = document.getElementById('trainButton');
            
            // Disable the train button during training
            trainButton.disabled = true;
            progressBar.style.width = '0%';
            statusText.textContent = 'Starting training...';
            accuracyDisplay.textContent = '';
            
            const eventSource = new EventSource(`/train?epochs=${epochs}`);
            
            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                
                if (data.status === 'error') {
                    statusText.textContent = `Error: ${data.message}`;
                    progressBar.classList.add('bg-danger');
                    eventSource.close();
                    trainButton.disabled = false;
                    return;
                }
                
                if (data.status === 'completed') {
                    statusText.textContent = data.message;
                    progressBar.style.width = '100%';
                    progressBar.classList.remove('bg-danger');
                    progressBar.classList.add('bg-success');
                    eventSource.close();
                    trainButton.disabled = false;
                    
                    // Add a small delay before getting accuracy
                    setTimeout(() => {
                        getModelAccuracy();
                    }, 1000);
                    return;
                }
                
                // Regular progress update
                if (data.batch !== undefined && data.total_batches !== undefined) {
                    const progress = (data.batch / data.total_batches) * 100;
                    progressBar.style.width = `${progress}%`;
                    statusText.textContent = `Epoch ${data.epoch}, Batch ${data.batch}/${data.total_batches}, ` +
                                          `Loss: ${data.loss.toFixed(4)}, Accuracy: ${data.accuracy.toFixed(2)}%`;
                }
            };
            
            eventSource.onerror = function(error) {
                console.error('EventSource error:', error);
                statusText.textContent = 'Training completed. Getting final accuracy...';
                progressBar.classList.add('bg-success');
                eventSource.close();
                trainButton.disabled = false;
                
                // Get accuracy after error/completion
                setTimeout(() => {
                    getModelAccuracy();
                }, 1000);
            };
        }

        function loadMNISTSamples() {
            fetch('/get_mnist_samples?num_samples=10')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const container = document.getElementById('mnistSamples');
                        container.innerHTML = '';
                        
                        data.samples.forEach(sample => {
                            const div = document.createElement('div');
                            div.className = 'mnist-sample';
                            div.innerHTML = `
                                <img src="data:image/png;base64,${sample.image}" alt="MNIST ${sample.label}">
                                <span class="label">Label: ${sample.label}</span>
                            `;
                            container.appendChild(div);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error loading MNIST samples:', error);
                });
        }

        function resetModel() {
            const resetButton = document.getElementById('resetButton');
            const trainButton = document.getElementById('trainButton');
            const statusText = document.getElementById('trainingStatus');
            const accuracyDisplay = document.getElementById('modelAccuracy');
            
            // Disable buttons during reset
            resetButton.disabled = true;
            trainButton.disabled = true;
            statusText.textContent = 'Resetting model weights...';
            
            fetch('/reset_model', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    statusText.textContent = 'Model reset successfully. Ready for training.';
                    if (data.accuracy !== undefined) {
                        accuracyDisplay.textContent = `Model Accuracy after reset: ${data.accuracy.toFixed(2)}%`;
                    }
                    // Clear any existing results since they're no longer valid
                    document.getElementById('resultContainer').innerHTML = '';
                } else {
                    statusText.textContent = `Error: ${data.error}`;
                }
            })
            .catch(error => {
                console.error('Error:', error);
                statusText.textContent = 'Error resetting model';
            })
            .finally(() => {
                // Re-enable buttons
                resetButton.disabled = false;
                trainButton.disabled = false;
            });
        }

        function getModelAccuracy() {
            const accuracyButton = document.getElementById('accuracyButton');
            const accuracyDisplay = document.getElementById('modelAccuracy');
            
            accuracyButton.disabled = true;
            accuracyDisplay.textContent = 'Calculating accuracy...';
            
            fetch('/get_accuracy')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        accuracyDisplay.textContent = `Model Accuracy: ${data.accuracy.toFixed(2)}%`;
                    } else {
                        accuracyDisplay.textContent = `Error getting accuracy: ${data.error}`;
                    }
                })
                .catch(error => {
                    accuracyDisplay.textContent = `Error: ${error.message}`;
                })
                .finally(() => {
                    accuracyButton.disabled = false;
                });
        }

        function loadDatasetInfo() {
            fetch('/get_dataset_info')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const info = data.info;
                        document.getElementById('trainSize').textContent = info.train_size.toLocaleString();
                    } else {
                        console.error('Error loading dataset info:', data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }

        // Load samples when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadMNISTSamples();
            loadDatasetInfo();
        });

        // Add these functions for hidden size control
        function initHiddenSizeControls() {
            const slider = document.getElementById('hiddenSizeSlider');
            const input = document.getElementById('hiddenSizeInput');
            
            slider.addEventListener('input', (e) => {
                input.value = e.target.value;
            });
            
            input.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                if (value < 1) input.value = 1;
                if (value > 256) input.value = 256;
                slider.value = input.value;
            });
        }
        
        function updateHiddenSize() {
            const newSize = parseInt(document.getElementById('hiddenSizeInput').value);
            const button = document.querySelector('.hidden-size-control button');
            button.disabled = true;
            
            fetch('/update_hidden_size', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ hidden_size: newSize })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Reload network visualization
                    loadNetworkInfo();
                    // Reset model accuracy display
                    const accuracyDisplay = document.getElementById('modelAccuracy');
                    if (accuracyDisplay) accuracyDisplay.textContent = '';
                } else {
                    alert('Error updating network: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error updating network');
            })
            .finally(() => {
                button.disabled = false;
            });
        }
        
        // Update the DOMContentLoaded event listener
        document.addEventListener('DOMContentLoaded', function() {
            initHiddenSizeControls();
            loadNetworkInfo();
            loadMNISTSamples();
        });

        function initLayerControls() {
            // Get current model architecture
            fetch('/get_network_info')
                .then(response => response.json())
                .then(data => {
                    const container = document.getElementById('layerInputs');
                    container.innerHTML = ''; // Clear existing inputs
                    
                    // Filter hidden layers
                    const hiddenLayers = data.layers.filter(layer => layer.name.includes('Hidden Layer'));
                    
                    // Add input for each hidden layer
                    hiddenLayers.forEach((layer, index) => {
                        const layerDiv = document.createElement('div');
                        layerDiv.className = 'layer-input';
                        layerDiv.innerHTML = `
                            <label>Hidden Layer ${index + 1}:</label>
                            <input type="number" class="layer-size" value="${layer.output_shape}" min="1" max="1000">
                            <span style="margin-left: 10px;">neurons</span>
                        `;
                        container.appendChild(layerDiv);
                    });
                })
                .catch(error => {
                    console.error('Error loading network architecture:', error);
                    // Add at least one layer as fallback
                    addLayer();
                });
        }
        
        function addLayer() {
            const container = document.getElementById('layerInputs');
            const layerCount = container.children.length;
            
            if (layerCount >= 5) {
                alert('Maximum 5 hidden layers allowed');
                return;
            }
            
            const layerDiv = document.createElement('div');
            layerDiv.className = 'layer-input';
            layerDiv.innerHTML = `
                <label>Hidden Layer ${layerCount + 1}:</label>
                <input type="number" class="layer-size" value="128" min="1" max="1000">
                <span style="margin-left: 10px;">neurons</span>
            `;
            
            container.appendChild(layerDiv);
        }
        
        function removeLayer() {
            const container = document.getElementById('layerInputs');
            if (container.children.length > 1) {
                container.removeChild(container.lastChild);
            }
        }
        
        function updateArchitecture() {
            const layers = Array.from(document.getElementsByClassName('layer-size'))
                .map(input => parseInt(input.value));
            
            if (!layers.every(size => size >= 1 && size <= 1000)) {
                alert('Each layer must have between 1 and 1000 neurons');
                return;
            }
            
            const button = document.querySelector('.update-btn');
            const statusText = document.getElementById('trainingStatus');
            button.disabled = true;
            statusText.textContent = 'Updating network architecture...';
            
            fetch('/update_hidden_size', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ layers: layers })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    statusText.textContent = `Network architecture updated successfully with layers: ${layers.join(', ')}`;
                    // Reload network visualization
                    loadNetworkInfo();
                    // Reset model accuracy display
                    const accuracyDisplay = document.getElementById('modelAccuracy');
                    if (accuracyDisplay) accuracyDisplay.textContent = 'Model architecture changed. Please train the model.';
                } else {
                    const errorMessage = data.error || 'Unknown error occurred';
                    statusText.textContent = `Error: ${errorMessage}`;
                    alert('Error updating network: ' + errorMessage);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                statusText.textContent = 'Failed to update network architecture';
                alert('Error updating network: ' + error.message);
            })
            .finally(() => {
                button.disabled = false;
            });
        }
        
        // Update the DOMContentLoaded event listener
        document.addEventListener('DOMContentLoaded', function() {
            initLayerControls();
            loadNetworkInfo();
            loadMNISTSamples();
        });
    </script>
</body>
</html> 